## Autogenerated by lu ##
import argparse
import os
import pathlib
import subprocess
import sys

## Autogenerated by lu ##
# cfg will attempt to retrive a configuration
# file the first time it is imported
import cfg
import lutils

# default values
default_quota_vals = {
    'block_grace' : '20w4d12h3m13s',
    'inode_grace' : '7200',
    'block_softlimit' : '20M',
    'block_hardlimit' : '30M',
    'inode_softlimit' : '2048',
    'inode_hardlimit' : '3072',
}
## Autogenerated by lu ##
# the usage string for this command
# it will be used as the main usage string
# if this command is called directly,
# or as the subcommand help string if called indirecly by lu
# required for use by lu
parser_help = '''setup and check edquot feature for lfs'''

## Autogenerated by lu ##
# a wrapper for set_up_parser_local
# allows for the case that an existing parser is
# being modified (which is the case when lu is using this
# module for a subcommand) and the case where this module
# is run as main, and no parser yet exists
def set_up_parser(parser=None):
    if parser is None:
        parser = argparse.ArgumentParser(usage=parser_help)
    # lu expects the parser to a field called 'func'
    # which is set to 'main' by default
    parser.set_defaults(func=main)
    set_up_parser_local(parser)
    return parser

## Autogenerated by lu ##
# set up the parser for this command
# the parser passed in is either one passed from
# lu, or one just created for this module
# part of all this infrastructure is to hopefully make
# it not matter what the context is, so this function
# can be written as if it's just for this module being
# called directly but it will work for lu as well
def set_up_parser_local(parser):
    pass

def setup_quota(fs_path='/mnt/lustre', user_name=None, **kwargs):
    '''set up lustre for quotas.'''

    if user_name is None:
        user_name = cfg.env.get('username')
    if user_name is None:
        sys.exit('ERROR: no username given or found in configuration file.')

    # use the default quota values unless some other value passed in
    quota_vals = {**default_quota_vals, **kwargs}

    # make the lustre file system writable
    mnt = pathlib.Path(fs_path)
    mnt.chmod(0o777)

    # find lctl
    lctl_path = str(lutils.find_lustre_path('lctl'))
    lfs_path = str(lutils.find_lustre_path('lfs'))

    # set up logging for quotas
    subprocess.run([lctl_path, 'set_param', 'debug=-1'])
    subprocess.run([lctl_path, 'set_param', 'subsystem_debug=lquota'])

    # turn on quotas for osts and mdts for users
    subprocess.run([lctl_path, 'conf_param', 'lustre.quota.ost=u'])
    subprocess.run([lctl_path, 'conf_param', 'lustre.quota.mdt=u'])

    # set grace periods for block and inode for users
    subprocess.run([lfs_path, 'setquota', '-t', '-u', 
                    '--block-grace', quota_vals['block_grace'],
                    '--inode-grace', quota_vals['inode_grace'], 
                    fs_path])    

    # set block limits for the user
    subprocess.run([lfs_path, 'setquota', '-u', user_name, 
                    '--block-softlimit', quota_vals['block_softlimit'],
                    '--block-hardlimit', quota_vals['block_hardlimit'],
                    fs_path])
    subprocess.run([lfs_path, 'setquota', '-u', user_name, 
                    '--inode-softlimit', quota_vals['inode_softlimit'],
                    '--inode-hardlimit', quota_vals['inode_hardlimit'],
                    fs_path])


def setup_test(reset=False):
    '''build lustre, mount lustre, make file system writeable, give myself a quota.
    if just doing a reset, first unmount, only call make when building, don't need to set the
    ip'''
    if reset:
        lutils.unmount_lustre()
    if reset:
        lutils.build_lustre(full=False)
    else:
        lutils.build_lustre(full=True)
    if not reset:
        lutils.set_ip()
    lutils.mount_lustre()
    setup_quota()


def check_under_quota(fs_path='/mnt/lustre'):
    '''see if correct output for lfs'''
        
    lfs_path = str(lutils.find_lustre_path('lfs'))
    user_name = cfg.env.get('username')
    quota_status = subprocess.run([lfs_path, 'quota', '-e', 
                                   '-u', user_name, fs_path],
                                  capture_output=True, 
                                  check=True).stdout.decode().strip()
    expected_status = f'{user_name} under quota on {fs_path}'
    if quota_status != expected_status:
        print('unexpected quota status:\n'
              f'expected: {expected_status}\nactual: {quota_status}',
              file=sys.stderr)


def write_to_lustre(n, fs_path='/mnt/lustre', filename='random_bytes_test'):
    '''write a n random bytes to a file'''
    output_file = pathlib.Path(fs_path) / filename

    # don't write negative length
    if n < 0:
        sys.exit(f'Can\'t write negative number of bytes {n} to {output_file}')

    with open(output_file, 'wb') as f:
        f.write(os.urandom(n))
        

def check_over_quota(fs_path='/mnt/lustre'):
    '''see if correct output for lfs'''
        
    lfs_path = str(lutils.find_lustre_path('lfs'))
    user_name = cfg.env.get('username')
    quota_status = subprocess.run([lfs_path, 'quota', '-e', 
                                   '-u', user_name, fs_path],
                                  capture_output=True, 
                                  check=True).stdout.decode().strip()
    expected_status = f'{user_name} under quota on {fs_path}'
    if quota_status != expected_status:
        print('unexpected quota status:\n'
              f'expected: {expected_status}\nactual: {quota_status}',
              file=sys.stderr)
    





def test_edquot():
    '''set up quotas, then check how the edquot stuff works'''
    # build and  mount lustre
    # setup user to have access to lustre, and a quota
    # check if edquot give the right results
    pass


## Autogenerated by lu ##
# the function that actually executes the command
# this function deals with the arguments after they are
# parsed and are made into a dictionary
def main(args):
    #setup_test(reset=True)
    #check_e_flag()
    #setup_quota(butt='hole')
    #check_under_quota()
    write_to_lustre(666)

## Autogenerated by lu ##
if __name__ == '__main__':
    parser = set_up_parser()
    args = vars(parser.parse_args())
    main(args)
