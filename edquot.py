## Autogenerated by lu ##
import argparse
import pathlib
import subprocess


## Autogenerated by lu ##
# cfg will attempt to retrive a configuration
# file the first time it is imported
import cfg
import lutils

## Autogenerated by lu ##
# the usage string for this command
# it will be used as the main usage string
# if this command is called directly,
# or as the subcommand help string if called indirecly by lu
# required for use by lu
parser_help = '''setup and check edquot feature for lfs'''

## Autogenerated by lu ##
# a wrapper for set_up_parser_local
# allows for the case that an existing parser is
# being modified (which is the case when lu is using this
# module for a subcommand) and the case where this module
# is run as main, and no parser yet exists
def set_up_parser(parser=None):
    if parser is None:
        parser = argparse.ArgumentParser(usage=parser_help)
    # lu expects the parser to a field called 'func'
    # which is set to 'main' by default
    parser.set_defaults(func=main)
    set_up_parser_local(parser)
    return parser




## Autogenerated by lu ##
# set up the parser for this command
# the parser passed in is either one passed from
# lu, or one just created for this module
# part of all this infrastructure is to hopefully make
# it not matter what the context is, so this function
# can be written as if it's just for this module being
# called directly but it will work for lu as well
def set_up_parser_local(parser):
    pass

def setup_quota(fs_path='/mnt/lustre', user_name=None):
    '''set up lustre for quotas.'''

    if user_name is None:
        user_name = cfg.env.get('username')
    if user_name is None:
        sys.exit('ERROR: no username given or found in configuration file.')
    
    # make the lustre file system writable
    mnt = pathlib.Path(fs_path)
    mnt.chmod(0o777)

    # find lctl
    lctl_path = str(path.find_lustre_path('lctl'))
    lfs_path = str(path.find_lustre_path('lfs'))

    # set up logging for quotas
    subprocess.run([lctl_path, 'set_param', 'debug=-1'])
    subprocess.run([lctl_path, 'set_param', 'subsystem_debug=lquota'])

    # turn on quotas for osts and mdts for users
    subprocess.run([lctl_path, 'conf_param', 'lustre.quota.ost=u'])
    subprocess.run([lctl_path, 'conf_param', 'lustre.quota.mdt=u'])

    # set grace periods for block and inode for users
    subprocess.run([lfs_path, 'setquota', '-t', '-u', '--block-grace', 
                    '20w4d12h3m13s', '--inode-grace', '7200', fs_path])    

    # set block limits for the user
    subprocess.run([lfs_path, 'setquota', '-u', user_name, 
                    '--block-softlimit', '20M', 
                    '--block-hardlimit', '30M', 
                    fs_path])
    subprocess.run([lfs_path, 'setquota', '-u', user_name, 
                    '--inode-softlimit', '2048', 
                    '--inode-hardlimit', '3072', 
                    fs_path])


def setup_test(reset=False):
    '''build lustre, mount lustre, make file system writeable, give myself a quota.
    if just doing a reset, first unmount, only call make when building, don't need to set the
    ip'''
    if reset:
        lutils.unmount_lustre()
    if reset:
        lutils.build_lustre(full=False)
    else:
        lutils.build_lustre(full=True)
    if not reset:
        lutils.set_ip()
    lutils.mount_lustre()
    setup_quota()


def check_e_flag():
    '''see if correct output for lfs'''
    pass


def test_edquot():
    '''set up quotas, then check how the edquot stuff works'''
    # build and  mount lustre
    # setup user to have access to lustre, and a quota
    # check if edquot give the right results
    pass


## Autogenerated by lu ##
# the function that actually executes the command
# this function deals with the arguments after they are
# parsed and are made into a dictionary
def main(args):
    setup_test(reset=True)

## Autogenerated by lu ##
if __name__ == '__main__':
    parser = set_up_parser()
    args = vars(parser.parse_args())
    main(args)
