## Autogenerated by lu ##
import argparse
import pathlib
import subprocess

## Autogenerated by lu ##
# cfg will attempt to retrive a configuration
# file the first time it is imported
import cfg
import lutils

## Autogenerated by lu ##
# the usage string for this command
# it will be used as the main usage string
# if this command is called directly,
# or as the subcommand help string if called indirecly by lu
# required for use by lu
parser_help = ('')

## Autogenerated by lu ##
# a wrapper for set_up_parser_local
# allows for the case that an existing parser is
# being modified (which is the case when lu is using this
# module for a subcommand) and the case where this module
# is run as main, and no parser yet exists
def set_up_parser(parser=None):
    if parser is None:
        parser = argparse.ArgumentParser(usage=parser_help)
    # lu expects the parser to a field called 'func'
    # which is set to 'main' by default
    parser.set_defaults(func=main)
    set_up_parser_local(parser)
    return parser

## Autogenerated by lu ##
# set up the parser for this command
# the parser passed in is either one passed from
# lu, or one just created for this module
# part of all this infrastructure is to hopefully make
# it not matter what the context is, so this function
# can be written as if it's just for this module being
# called directly but it will work for lu as well
def set_up_parser_local(parser):
    parser.add_argument('-s', '--suffixes', nargs='*',
                        help='the file suffixes that will be included ' 
                        'in the tags file. The suffix may or may not have a \.\ at '
                        'the beggining. For example, \'.sh\' and \'sh\' will be treated '
                        'the same.')
    parser.add_argument('-d', '--default', choices=['yes', 'no'],
                         help='include the default suffixes which are \'.c\' \'.h\' and \'.sh\' '
                         'This option defaults to yes.')
    parser.add_argument('-o', '--outputfile',
                        help='the file to store the tags in, by default this ' 
                        'is \'TAGS\' in the top directory ' 
                        'of lustre. It may be useful to have multiple files in case there are conflicting names.')


def filter_files(topdir, suffixes=None, use_defaults=True):
    '''recursively find all files in topdir that have 
    the given suffixes.'''
    # check that topdir is a dir, othrrwise fail
    root = pathlib.Path(topdir).resolve()
    if not root.is_dir():
        sys.exit(f'cannot find files rooted at {str(root)}, ' 
                 f'{str(root)} is not a directory.')

    # no suffixes to match, so do nothing
    if suffixes is None and not use_defaults:
        return []

    default_suffixes = ('.c', '.h', '.sh')

    # convert given suffixes to be list even if none given
    if suffixes is None:
        suffixes = []
    # prepend each suffix with '.' if needed
    suffixes = [('.' + s if not s.startswith('.') else s) for s in suffixes]
    # use each suffix only once
    all_suffixes = suffixes if not use_defaults else list({*suffixes, *default_suffixes})

    # grab all the files
    paths = root.rglob('*')

    # keep only the ones with the good suffixes
    return [p for p in paths if p.suffix in all_suffixes]


def make_tags(paths, outputfile=None):
    '''make a tags file. if outputfile not given,
    just use lustre_root/TAGS'''
    outputdir = lutils.find_lustre()

    # convert into bytes for piping
    #paths = bytes(' '.join(map(str,paths)) + '\n', 'utf-8')

    # set output file if specified
    etags_args = ['etags', '--append']
    if outputfile is not None:
        etags_args += ['--output', outputfile]
    etags_args += paths
    # now pipe the paths into etags
    subprocess.run(etags_args, #input=paths, 
                   cwd=outputdir, check=True)


## Autogenerated by lu ##
# the function that actually executes the command
# this function deals with the arguments after they are
# parsed and are made into a dictionary
def main(args):
    # find lustre
    lustre_path = lutils.find_lustre()

    # check if default suffixes are to be used
    use_defaults = args.get('defaults')
    if use_defaults is None or use_defaults == 'yes': 
        use_defaults = True
    else:
        use_defaults = False

    # get all the files for tagging
    paths = filter_files(lustre_path,
                         suffixes=args.get('suffixes'),
                         use_defaults=use_defaults)
    # nothing to do
    if paths == []:
        return

    make_tags(paths, args.get('outputfile'))


## Autogenerated by lu ##
if __name__ == '__main__':
    parser = set_up_parser()
    args = vars(parser.parse_args())
    main(args)
