## Autogenerated by lu ##
import argparse
import collections
import pathlib

## Autogenerated by lu ##
# cfg will attempt to retrive a configuration
# file the first time it is imported
import cfg
import lutils

## Autogenerated by lu ##
# the usage string for this command
# it will be used as the main usage string
# if this command is called directly,
# or as the subcommand help string if called indirecly by lu
# required for use by lu
parser_help = ('get a path within the lustre source code. '
               'This command will attempt to find the root of the lustre source code '
               'using user given base names or default base name. '
               'The check to make sure that the given base name is actually lustre is very weak '
               'it just checks if the path is a non-empty directory. '
               'Then a relative path will be added to give the full name.')

## Autogenerated by lu ##
# a wrapper for set_up_parser_local
# allows for the case that an existing parser is
# being modified (which is the case when lu is using this
# module for a subcommand) and the case where this module
# is run as main, and no parser yet exists
def set_up_parser(parser=None):
    if parser is None:
        parser = argparse.ArgumentParser(usage=parser_help)
    # lu expects the parser to a field called 'func'
    # which is set to 'main' by default
    parser.set_defaults(func=main)
    set_up_parser_local(parser)
    return parser

## Autogenerated by lu ##
# set up the parser for this command
# the parser passed in is either one passed from
# lu, or one just created for this module
# part of all this infrastructure is to hopefully make
# it not matter what the context is, so this function
# can be written as if it's just for this module being
# called directly but it will work for lu as well
def set_up_parser_local(parser):
    parser.add_argument('-s', '--show', action='store_true',
        help='show default base paths and relative paths.')
    parser.add_argument('-b', '--base_paths', nargs='*',
        help='set base paths, these paths will be used as the root of the lustre source code '
        'if they are non-empty directories. If none of the given base paths '
        'is plausibly the root of the lustre source code, the default base '
        'paths will be checked next, unless --default is set to no.')
    parser.add_argument('-d', '--default', choices=['yes', 'no', 'first'],
        help='control the order in which base paths are checked. '
        'if \'yes\' the default base paths will be checked after any given base paths. '
        'if \'no\' the default base paths will not be checked. '
        'if \'first\', the default base paths will be checked before any given base paths '
        'the default is \'yes\'')
    parser_mutex = parser.add_mutually_exclusive_group()
    parser_mutex.add_argument('-n', '--name',
        help='the name of some path in the lustre source tree. '
        'It will br translated into a path relative to the base path '
        'if it is a known name. To see the known names use --show.')
    parser_mutex.add_argument('-r', '--relative', nargs='?', const='',
        help='the relative path name. This will be added onto '
        'the lustre root path making <lustre source root>/<relative path>')
    parser.set_defaults(func=main)


def show_paths():
    '''Show all default base paths,  as well as relative path names
    and their corresponding paths.'''
    lutils.print_rgb((125,56,179), 'default base paths:')
    for p in lutils.default_lustre_paths:
        print(str(p))
    lutils.print_rgb((125,56,179), 'relative paths:')
    for n,p in lutils.lustre_relative_paths.items():
        print(n + ' -> \'' + p + '\'')


## Autogenerated by lu ##
# the function that actually executes the command
# this function deals with the arguments after they are
# parsed and are made into a dictionary
def main(args):
    '''Deal with arguments and call appropriate
    functions.
    '''
    if args['show']:
        show_paths()

    base_paths = args.get('base_paths')
    if base_paths == []:
        base_paths = None

    default = args.get('default')
    relative = args.get('relative')
    check_defaults = None
    check_defaults_first = None
    if default == 'yes':
        check_defaults = True
        check_defaults_first = False
    if default == 'first':
        check_defaults = True
        check_defaults_first = True
    if default == 'no':
        check_defaults = False
        check_defaults_first = False
    lustre_root = find_lustre(base_paths, 
                              check_defaults,
                              check_defaults_first)

    # mutally exclusive if blocks based on parser
    if args['name'] is not None:
        full_path = find_path(lustre_root, args['name'])
        if full_path is not None:
            print(full_path)
    if args['relative']:
        print(lustre_root / relative)

## Autogenerated by lu ##
if __name__ == '__main__':
    parser = set_up_parser()
    args = vars(parser.parse_args())
    main(args)
